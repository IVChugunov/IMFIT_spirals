// See run_unittest_utilities.sh for how to compile and run these tests.

// older compilation notes:
// $CXXTESTGEN --error-printer -o test_runner_utilities.cpp unittest_utilities.t.h
// $CPP -o test_runner_utilities test_runner_utilities.cpp utilities.cpp -I/usr/local/include -I$CXXTEST
// ./test_runner_utilities

#include <cxxtest/TestSuite.h>

#include <string>
#include <vector>
#include <tuple>
using namespace std;
#include "utilities_pub.h"


class NewTestSuite : public CxxTest::TestSuite 
{
public:

  // Tests for PrintToString()
  void testPrintToString_Basic( void )
  {
    string  ref1 = "10 words";
    string  ref2 = "10 words 20";
    string  ref3 = "Alfred is 1.2 years old";
    
    string  test1 = PrintToString("%d words", 10);
    string  test2 = PrintToString("%d words %d", 10, 20);
    string  test3 = PrintToString("%s is %.1f years old", "Alfred", 1.21);

    TS_ASSERT( test1 == ref1 );
    TS_ASSERT( test2 == ref2 );
    TS_ASSERT( test3 == ref3 );
  }


  // Tests for PrepareImageComments()
  // Default mode used by makeimage
  void testPrepareImageCommentsMakeimage_NoPSF( void )
  {
    string  progName = "makeimage v1.0";
    string  configFilename = "config.dat";
    string  psfFilename;   // in "no PSF" mode we assume this is unassigned
    bool  psfInUse = false;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 2 );
    
    string  refLine1 = "Model image generated by makeimage v1.0";
    string  refLine2 = "Using config file config.dat";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
  }

  void testPrepareImageCommentsMakeimage_WithPSF( void )
  {
    string  progName = "makeimage v1.0";
    string  configFilename = "config.dat";
    string  psfFilename = "some_psf.fits";
    bool  psfInUse = true;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 3 );
    
    string  refLine1 = "Model image generated by makeimage v1.0";
    string  refLine2 = "Using config file config.dat";
    string  refLine3 = "Using convolution with PSF image some_psf.fits";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
    TS_ASSERT( commentList[2] == refLine3 );
  }

  void testPrepareImageCommentsModel_NoPSF( void )
  {
    string  progName = "imfit v1.0";
    string  configFilename = "config.dat";
    string  dataFilename = "data.fits";
    string  psfFilename;   // in "no PSF" mode we assume this is unassigned
    bool  psfInUse = false;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename,
    					HDR_MODELIMAGE, dataFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 3 );
    
    string  refLine1 = "Model image generated by imfit v1.0";
    string  refLine2 = "From fit to data image data.fits";
    string  refLine3 = "Using config file config.dat";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
    TS_ASSERT( commentList[2] == refLine3 );
  }

  void testPrepareImageCommentsResidual_NoPSF( void )
  {
    string  progName = "imfit v1.0";
    string  configFilename = "config.dat";
    string  dataFilename = "data.fits";
    string  psfFilename;   // in "no PSF" mode we assume this is unassigned
    bool  psfInUse = false;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename,
    					HDR_RESIDUALIMAGE, dataFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 3 );
    
    string  refLine1 = "Residual image generated by imfit v1.0";
    string  refLine2 = "Data image data.fits - best-fitting model image";
    string  refLine3 = "Using config file config.dat";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
    TS_ASSERT( commentList[2] == refLine3 );
  }

  void testPrepareImageCommentsModel_WithPSF( void )
  {
    string  progName = "imfit v1.0";
    string  configFilename = "config.dat";
    string  dataFilename = "data.fits";
    string  psfFilename = "some_psf.fits";
    bool  psfInUse = true;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename,
    					HDR_MODELIMAGE, dataFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 4 );
    
    string  refLine1 = "Model image generated by imfit v1.0";
    string  refLine2 = "From fit to data image data.fits";
    string  refLine3 = "Using config file config.dat";
    string  refLine4 = "Using convolution with PSF image some_psf.fits";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
    TS_ASSERT( commentList[2] == refLine3 );
    TS_ASSERT( commentList[3] == refLine4 );
  }

  void testPrepareImageCommentsResidual_WithPSF( void )
  {
    string  progName = "imfit v1.0";
    string  configFilename = "config.dat";
    string  dataFilename = "data.fits";
    string  psfFilename = "some_psf.fits";
    bool  psfInUse = true;
    int  nComments;
    vector<string>  commentList;
    
    PrepareImageComments(&commentList, progName, configFilename, psfInUse, psfFilename,
    					HDR_RESIDUALIMAGE, dataFilename);
    
    nComments = (int)commentList.size();
    TS_ASSERT( nComments == 4 );
    
    string  refLine1 = "Residual image generated by imfit v1.0";
    string  refLine2 = "Data image data.fits - best-fitting model image";
    string  refLine3 = "Using config file config.dat";
    string  refLine4 = "Using convolution with PSF image some_psf.fits";

    TS_ASSERT( commentList[0] == refLine1 );
    TS_ASSERT( commentList[1] == refLine2 );
    TS_ASSERT( commentList[2] == refLine3 );
    TS_ASSERT( commentList[3] == refLine4 );
  }
  
  
  // Tests for SplitString()
  void testSplitString_Basic( void )
  {
    string  s1 = "two words";
    vector<string>  s1_split;
    vector<string>  correctResult12;
    correctResult12.push_back("two");
    correctResult12.push_back("words");
    SplitString(s1, s1_split);
    TS_ASSERT( s1_split == correctResult12 );

    string  s2 = "   two words    ";
    vector<string>  s2_split;
    SplitString(s2, s2_split);
    TS_ASSERT( s2_split == correctResult12 );

    string  s3 = "\tthree words\t now";
    vector<string>  s3_split;
    vector<string>  correctResult3;
    correctResult3.push_back("three");
    correctResult3.push_back("words");
    correctResult3.push_back("now");
    SplitString(s3, s3_split);
    TS_ASSERT( s3_split == correctResult3 );

    string  s4 = "onelongword";
    vector<string>  s4_split;
    vector<string>  correctResult4;
    correctResult4.push_back("onelongword");
    SplitString(s4, s4_split);
    TS_ASSERT( s4_split == correctResult4 );
  }

  void testSplitString_csv( void )
  {
    string  s1 = "two,words";
    vector<string>  s1_split;
    vector<string>  correctResult12;
    correctResult12.push_back("two");
    correctResult12.push_back("words");
    SplitString(s1, s1_split, ",");
    TS_ASSERT( s1_split == correctResult12 );
  }

  void testSplitString_storage( void )
  // test to make sure that SplitString() clears the supplied vector
  // before storing things in it
  {
    string  s1 = "two words";
    string  s2 = "more words";
    vector<string>  s_split;
    vector<string>  correctResult;
    correctResult.push_back("more");
    correctResult.push_back("words");
    SplitString(s1, s_split);
    SplitString(s2, s_split);
    TS_ASSERT( s_split == correctResult );
  }
  

  void testSplitStringAdd_storage( void )
  // test to make sure that SplitStringAdd() does *not* clear the supplied vector
  // before storing things in it
  {
    string  s1 = "two words";
    string  s2 = "more words";
    vector<string>  s_split;
    vector<string>  correctResult;
    correctResult.push_back("two");
    correctResult.push_back("words");
    correctResult.push_back("more");
    correctResult.push_back("words");
    SplitStringAdd(s1, s_split);
    SplitStringAdd(s2, s_split);
    TS_ASSERT( s_split == correctResult );
  }
  

  // Tests for TrimWhitespace()
  void testTrimWhitespace( void )
  {
    string  s1 = "\t\ttext with tabs\t";
    string  correctResult1 = "text with tabs";
    string  s2 = "   singleword";
    string  correctResult2 = "singleword";
    string  s3 = "\tsingleword";
    string  correctResult3 = "singleword";
    string  s4 = "singleword\t";
    string  correctResult4 = "singleword";
    TrimWhitespace(s1);
    TS_ASSERT( s1 == correctResult1 );
    TrimWhitespace(s2);
    TS_ASSERT( s2 == correctResult2 );
    TrimWhitespace(s3);
    TS_ASSERT( s3 == correctResult3 );
    TrimWhitespace(s4);
    TS_ASSERT( s4 == correctResult4 );
  }


  // Tests for ChopComment()
  void testChopComment_Standard( void )
  {
    string  s1 = "text # with comment";
    string  correctResult1 = "text ";
    string  s2 = "#text # with comment";
    string  correctResult2 = "";
    ChopComment(s1);
    TS_ASSERT( s1 == correctResult1 );
    ChopComment(s2);
    TS_ASSERT( s2 == correctResult2 );
  }

  void testChopComment_Alternate( void )
  {
    string  s1 = "text ; with comment";
    string  correctResult1 = "text ";
    string  s2 = ";text # with comment";
    string  correctResult2 = "";
    ChopComment(s1, ';');
    TS_ASSERT( s1 == correctResult1 );
    ChopComment(s2, ';');
    TS_ASSERT( s2 == correctResult2 );
  }
  
  
  // Tests for ImageFileExists()
  void testImageFileExists_internet( void )
  {
    TS_ASSERT( ImageFileExists("ftp://www.blah.com/something") == true);
    TS_ASSERT( ImageFileExists("http://www.blah.com/something") == true);
  }

  void testImageFileExists_NonexistentFile( void )
  {
    TS_ASSERT( ImageFileExists("/Users/erwin/coding/imfit/testing/nohow.fits") == false);
  }
  
  void testImageFileExists_RealFile( void )
  {
    TS_ASSERT( ImageFileExists("./tests/n3073rss_small.fits") == true);
  }
  
  void testImageFileExists_RealFileWithSection( void )
  {
    TS_ASSERT( ImageFileExists("./tests/n3073rss_small.fits[100:200,200:300]") == true);
  }

  void testImageFileExists_RealFileWithExtension( void )
  {
    TS_ASSERT( ImageFileExists("./tests/n3073rss_small.fits[1]") == true);
  }

  void testImageFileExists_RealFileWithExtensionAndSection( void )
  {
    TS_ASSERT( ImageFileExists("./tests/n3073rss_small.fits[1][100:200,200:300]") == true);
  }
  
  
  // Tests for FileExists()
  void testFileExists_RealFile( void )
  {
    TS_ASSERT( FileExists("/bin/ls") == true);
  }
   
  void testFileExists_NonexistentFile( void )
  {
    TS_ASSERT( FileExists("/Users/erwin/coding/testing/nobody-nohow.dat") == false);
  }


  // Tests for StripBrackets()
  void testStripBrackets_NormalFiles( void )
  {
    string  s1_out, s2_out;
    string  s1 = "image.fits";
    string  correctResult1 = "image.fits";
    string  s2 = "image.fit";
    string  correctResult2 = "image.fit";
    StripBrackets(s1, s1_out);
    TS_ASSERT( s1_out == correctResult1 );
    StripBrackets(s2, s2_out);
    TS_ASSERT( s2_out == correctResult2 );
  }

  void testStripBrackets_WithBrackets( void )
  {
    string  s1_out, s2_out;
    string  s1 = "image.fits[100:200,300:400]";
    string  correctResult1 = "image.fits";
    string  s2 = "image.fit[100:200,300:400]";
    string  correctResult2 = "image.fit";
    StripBrackets(s1, s1_out);
    TS_ASSERT( s1_out == correctResult1 );
    StripBrackets(s2, s2_out);
    TS_ASSERT( s2_out == correctResult2 );
  }



  // Tests for GetAllCoordsFromBrackets()
  void testGetAllCoordsFromBrackets_BasicSections( void )
  {
    string  s1("100:200,200:400");
    string  s2("245:265,245:255");
    string  s3("[245:265,245:255]");
    int  x1, y1, x2, y2;
    int  correct_x1a = 100;
    int  correct_x2a = 200;
    int  correct_y1a = 200;
    int  correct_y2a = 400;
    int  correct_x1b = 245;
    int  correct_x2b = 265;
    int  correct_y1b = 245;
    int  correct_y2b = 255;
    std::tie(x1, x2, y1, y2) = GetAllCoordsFromBracket(s1);
    TS_ASSERT( x1 == correct_x1a );
    TS_ASSERT( x2 == correct_x2a );
    TS_ASSERT( y1 == correct_y1a );
    TS_ASSERT( y2 == correct_y2a );
    std::tie(x1, x2, y1, y2) = GetAllCoordsFromBracket(s2);
    TS_ASSERT( x1 == correct_x1b );
    TS_ASSERT( x2 == correct_x2b );
    TS_ASSERT( y1 == correct_y1b );
    TS_ASSERT( y2 == correct_y2b );
    std::tie(x1, x2, y1, y2) = GetAllCoordsFromBracket(s3);
    TS_ASSERT( x1 == correct_x1b );
    TS_ASSERT( x2 == correct_x2b );
    TS_ASSERT( y1 == correct_y1b );
    TS_ASSERT( y2 == correct_y2b );
  }



  // Tests for GetStartCoordsFromBrackets()
  void testGetStartCoordsFromBrackets_BasicSections( void )
  {
    string  fn1("imagefile.fits[100:200,200:400]");
    string  s1("100:200,200:400");
    int  x1, y1, x2, y2;
    int  correct_xoff = 100;
    int  correct_yoff = 200;
    std::tie(x1,y1) = GetStartCoordsFromBracket(s1, fn1);
    TS_ASSERT( x1 == correct_xoff );
    TS_ASSERT( y1 == correct_yoff );
  }

  void testGetStartCoordsFromBrackets__StarredSections( void )
  {
    string  fn1("image.fits[*,200:400]");
    string  fn2("image.fits[100:200,*]");
    string  s1("*,200:400");
    string  s2("100:200,*");
    int  x1, y1, x2, y2;
    int  correct_xoff1 = 1;
    int  correct_yoff1 = 200;
    int  correct_xoff2 = 100;
    int  correct_yoff2 = 1;
    std::tie(x1,y1) = GetStartCoordsFromBracket(s1, fn1);
    TS_ASSERT( x1 == correct_xoff1 );
    TS_ASSERT( y1 == correct_yoff1 );
    std::tie(x2,y2) = GetStartCoordsFromBracket(s2, fn2);
    TS_ASSERT( x2 == correct_xoff2 );
    TS_ASSERT( y2 == correct_yoff2 );
  }



  // Tests for GetPixelStartCoords()
  void testGetPixelStartCoords_NoSection( void )
  {
    string  s1("image.fits");
    string  s2("complicated_name_image.fit");
    int  x1, y1, x2, y2;
    int  correct_xoff = 1;
    int  correct_yoff = 1;
    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff );
    TS_ASSERT( y1 == correct_yoff );
    std::tie(x2,y2) = GetPixelStartCoords(s2);
    TS_ASSERT( x2 == correct_xoff );
    TS_ASSERT( y2 == correct_yoff );
  }

  void testGetPixelStartCoords_BadSections( void )
  {
    string  s1("image.fits[100:200,200:400");
    string  s2("complicated_name_image.fit[100:200,200:400[");
    string  s3("image.fits[][100:200,200:400]");
    int  x1, y1, x2, y2, x3, y3;
    int  correct_xoff = 0;
    int  correct_yoff = 0;
    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff );
    TS_ASSERT( y1 == correct_yoff );
    std::tie(x2,y2) = GetPixelStartCoords(s2);
    TS_ASSERT( x2 == correct_xoff );
    TS_ASSERT( y2 == correct_yoff );
    std::tie(x3,y3) = GetPixelStartCoords(s3);
    TS_ASSERT( x3 == correct_xoff );
    TS_ASSERT( y3 == correct_yoff );
  }

  void testGetPixelStartCoords_BasicSections( void )
  {
    string  s1("image.fits[100:200,200:400]");
    string  s2("complicated_name_image.fit[100:200,200:400]");
    int  x1, y1, x2, y2;
    int  correct_xoff = 100;
    int  correct_yoff = 200;
    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff );
    TS_ASSERT( y1 == correct_yoff );
    std::tie(x2,y2) = GetPixelStartCoords(s2);
    TS_ASSERT( x2 == correct_xoff );
    TS_ASSERT( y2 == correct_yoff );
  }

  void testGetPixelStartCoords_StarredSections( void )
  {
    string  s1("image.fits[*,200:400]");
    string  s2("image.fits[100:200,*]");
    int  x1, y1, x2, y2;
    int  correct_xoff1 = 1;
    int  correct_yoff1 = 200;
    int  correct_xoff2 = 100;
    int  correct_yoff2 = 1;
    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff1 );
    TS_ASSERT( y1 == correct_yoff1 );
    std::tie(x2,y2) = GetPixelStartCoords(s2);
    TS_ASSERT( x2 == correct_xoff2 );
    TS_ASSERT( y2 == correct_yoff2 );
  }


  void testGetPixelStartCoords_ComplexSections( void )
  {
    string  s1("image.fits[2][100:200,200:400]");
    string  s2("image.fits[105][100:200,*]");
    string  s3("complicated_name_image.fit[5]");

    int  x1, y1, x2, y2, x3, y3;
    int  correct_xoff1 = 100;
    int  correct_yoff1 = 200;
    int  correct_xoff2 = 100;
    int  correct_yoff2 = 1;
    int  correct_xoff3 = 1;
    int  correct_yoff3 = 1;
    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff1 );
    TS_ASSERT( y1 == correct_yoff1 );
    std::tie(x2,y2) = GetPixelStartCoords(s2);
    TS_ASSERT( x2 == correct_xoff2 );
    TS_ASSERT( y2 == correct_yoff2 );
    std::tie(x3,y3) = GetPixelStartCoords(s3);
    TS_ASSERT( x3 == correct_xoff3 );
    TS_ASSERT( y3 == correct_yoff3 );
  }




  // Tests for DetermineImageOffset
  void testDetermineImageOffset( void )
  {
    string  s1("image.fits[51:200,41:190]");
    string  s1_region("100:110,100:110");
    int  X0_offset, Y0_offset;
    int  x1, y1, x2, y2;
    int  x1_oversample, y1_oversample, x2_oversample, y2_oversample;
    int  correct_xoff = 51;
    int  correct_yoff = 41;
    int  correct_x1_oversamp = 50;
    int  correct_x2_oversamp = 60;
    int  correct_y1_oversamp = 60;
    int  correct_y2_oversamp = 70;

    std::tie(x1,y1) = GetPixelStartCoords(s1);
    TS_ASSERT( x1 == correct_xoff );
    TS_ASSERT( y1 == correct_yoff );
    
    std::tie(X0_offset, Y0_offset) = DetermineImageOffset(s1);
    std::tie(x1_oversample, x2_oversample, y1_oversample, y2_oversample) = GetAllCoordsFromBracket(s1_region);
    x1_oversample -= X0_offset;
    x2_oversample -= X0_offset;
    y1_oversample -= Y0_offset;
    y2_oversample -= Y0_offset;
    TS_ASSERT_EQUALS(x1_oversample, correct_x1_oversamp);
    TS_ASSERT_EQUALS(x2_oversample, correct_x2_oversamp);
    TS_ASSERT_EQUALS(y1_oversample, correct_y1_oversamp);
    TS_ASSERT_EQUALS(y2_oversample, correct_y2_oversamp);
  }


  
  // Tests for NotANumber()
  void testNotANumberWithInts( void )
  {
    bool  t1 = NotANumber( "5", 0, kAnyInt );
    TS_ASSERT( t1 == false);
    bool  t2 = NotANumber( "-5", 1, kAnyInt );
    TS_ASSERT( t2 == false);
    bool  t3 = NotANumber( "5", 0, kPosInt );
    TS_ASSERT( t3 == false);
    // Now test that 0 is "not a number" for kPosInt
    bool  t4 = NotANumber( "0", 0, kPosInt );
    TS_ASSERT( t4 == true);
    // Now test that a is "not a number" for kPosInt
    bool  t5 = NotANumber( "a", 0, kPosInt );
    TS_ASSERT( t5 == true);
    // Now test that ".1" is "not a number" for kPosInt
    bool  t6 = NotANumber( ".1", 0, kPosInt );
    TS_ASSERT( t6 == true);
  }

  void testNotANumberWithReals( void )
  {
    // Tests for kAnyReal
    bool  t1 = NotANumber( "5.7", 0, kAnyReal );
    TS_ASSERT( t1 == false);
    bool  t2 = NotANumber( "-5.7", 1, kAnyReal );
    TS_ASSERT( t2 == false);
    bool  t3 = NotANumber( ".57", 0, kAnyReal );
    TS_ASSERT( t3 == false);
    bool  t3b = NotANumber( "0", 0, kAnyReal );
    TS_ASSERT( t3b == false);
    bool  t4 = NotANumber( "-.57", 0, kAnyReal );
    TS_ASSERT( t4 == false);
    // Now test that a is "not a number" for kAnyReal
    bool  t5 = NotANumber( "a", 0, kAnyReal );
    TS_ASSERT( t5 == true);
    // Tests for kPosReal
    bool  t6 = NotANumber( "5.7", 0, kPosReal );
    TS_ASSERT( t6 == false);
    bool  t7 = NotANumber( ".57", 0, kPosReal );
    TS_ASSERT( t7 == false);
    // Now test for "not a number" for kPosReal
    bool  t8 = NotANumber( "a", 0, kPosReal );
    TS_ASSERT( t8 == true);
    bool  t9 = NotANumber( "-.57", 0, kPosReal );
    TS_ASSERT( t9 == true);
    bool  t10 = NotANumber( "-0.2", 0, kPosReal );
    TS_ASSERT( t10 == true);
    // THE FOLLOWING DOES NOT WORK -- APPARENTLY RETURNS FALSE!
    bool  t11 = NotANumber( "-5.7", 0, kPosReal );
    TS_ASSERT( t11 == true);
  }


  void testIsNumeric_goodStrings( void )
  {
    int  t1 = IsNumeric("5.7");
    TS_ASSERT_DIFFERS(t1, 0);
    int  t2 = IsNumeric("-5.7");
    TS_ASSERT_DIFFERS(t2, 0);
    int  t3 = IsNumeric("5");
    TS_ASSERT_DIFFERS(t3, 0);
    int  t4 = IsNumeric("0");
    TS_ASSERT_DIFFERS(t4, 0);
    int  t5 = IsNumeric("70000.");
    TS_ASSERT_DIFFERS(t5, 0);
    int  t6 = IsNumeric("-10");
    TS_ASSERT_DIFFERS(t6, 0);
  }

  void testIsNumeric_badStrings( void )
  {
    int  t1 = IsNumeric("5.o");
    TS_ASSERT_EQUALS(t1, 0);
    int  t2 = IsNumeric("bad");
    TS_ASSERT_EQUALS(t2, 0);
    int  t3 = IsNumeric("25..7");
    TS_ASSERT_EQUALS(t3, 0);
    int  t4 = IsNumeric("5-4");
    TS_ASSERT_EQUALS(t4, 0);
  }

};
