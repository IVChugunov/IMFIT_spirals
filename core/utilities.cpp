/* FILE: utilities.cpp --------------------------------------------- */
/*   Several utility routines used by imfit, makeimage, etc.
 */

// Copyright 2010-2018 by Peter Erwin.
// 
// This file is part of Imfit.
// 
// Imfit is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your
// option) any later version.
// 
// Imfit is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
// 
// You should have received a copy of the GNU General Public License along
// with Imfit.  If not, see <http://www.gnu.org/licenses/>.


#include <ctype.h>   /* for isdigit() */
#include <stdio.h>
#include <stdlib.h>  /* for exit() */
#include <time.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdarg>
#include <tuple>

using namespace std;

#include "utilities_pub.h"
#include "param_struct.h"
#include "statistics.h"

/* ------------------- Function Prototypes ----------------------------- */
/* Local Functions: */
string vformat( const char *fmt, va_list ap );



// The following two functions are taken from 
// http://stackoverflow.com/questions/69738/c-how-to-get-fprintf-results-as-a-stdstring-w-o-sprintf#69911
// and are originally written by Larry Gritz, August 2009
// ("This code is part of an open source project that I'm writing (BSD license), 
// so everybody feel free to use this as you wish.")

// Public function, which is mostly a wrapper around vformat
string PrintToString( const char *fmt, ... )
{
  va_list ap;
  va_start(ap, fmt);
  string  buf = vformat(fmt, ap);
  va_end(ap);
  return buf;
}

// Main function which does the work for PrintToString
string vformat( const char *fmt, va_list ap )
{
  // Allocate a buffer on the stack that's big enough for us almost
  // all the time.  Be prepared to allocate dynamically if it doesn't fit.
  const size_t INITIAL_BUFFER_SIZE = 1024;
  size_t  size = INITIAL_BUFFER_SIZE;
  char  stackbuf[INITIAL_BUFFER_SIZE];
  vector<char>  dynamicbuf;
  char *buf = &stackbuf[0];

  while (1) {
    // Try to vsnprintf into our buffer.
    int  needed = vsnprintf(buf, size, fmt, ap);
    // NB. C99 (which modern Linux and OS X follow) says vsnprintf
    // failure returns the length it would have needed.  But older
    // glibc and current Windows return -1 for failure, i.e., not
    // telling us how much was needed.

    if (needed <= (int)size && needed >= 0) {
      // It fit fine so we're done.
      return string(buf, (size_t)needed);
    }

    // vsnprintf reported that it wanted to write more characters
    // than we allotted.  So try again using a dynamic buffer.  This
    // doesn't happen very often if we chose our initial size well.
    size = (needed > 0) ? (needed+1) : (size*2);
    dynamicbuf.resize(size);
    buf = &dynamicbuf[0];
  }
}



/* ---------------- FUNCTION: MakeOutputHeader() ------------------- */

void MakeOutputHeader( vector<string> *headerLines, const string& programName, 
						const int argc, char *argv[] )
{  
  char  *timeStamp = TimeStamp();
  string  tempString;

  tempString = PrintToString("# Best-fit model results for %s", programName.c_str());
  headerLines->push_back(tempString);
  tempString = PrintToString("# Generated on %s by the following command:", 
          timeStamp);
  headerLines->push_back(tempString);
  tempString = "#   ";
  for (int i = 0; i < argc; i++) {
    tempString += PrintToString(" %s", argv[i]);
  }
  headerLines->push_back(tempString);
}



/* ---------------- FUNCTION: PrepareImageComments() --------------- */

void PrepareImageComments( vector<string> *comments, const string &programName, 
                           const string &configFileName, bool psfUsed, 
                           const string &psfFileName, int mode, const string &dataFileName )
{
  string  newString;
  
  switch (mode) {
    case HDR_MAKEIMAGE:
      newString = PrintToString("Model image generated by %s", programName.c_str());
      comments->push_back(string(newString));
      newString = PrintToString("Using config file %s", configFileName.c_str());
      comments->push_back(string(newString));
      break;
    case HDR_MODELIMAGE:
      newString = PrintToString("Model image generated by %s", programName.c_str());
      comments->push_back(string(newString));
      newString = PrintToString("From fit to data image %s", dataFileName.c_str());
      comments->push_back(string(newString));
      newString = PrintToString("Using config file %s", configFileName.c_str());
      comments->push_back(string(newString));
      break;
    case HDR_RESIDUALIMAGE:
      newString = PrintToString("Residual image generated by %s", programName.c_str());
      comments->push_back(string(newString));
      newString = PrintToString("Data image %s - best-fitting model image", dataFileName.c_str());
      comments->push_back(string(newString));
      newString = PrintToString("Using config file %s", configFileName.c_str());
      comments->push_back(string(newString));
      break;
    case HDR_WEIGHTIMAGE:
      newString = PrintToString("Weight image generated by %s", programName.c_str());
      comments->push_back(string(newString));
      break;
  }
  if (psfUsed) {
    newString = PrintToString("Using convolution with PSF image %s", psfFileName.c_str());
    comments->push_back(string(newString));
  }
}



/* ---------------- FUNCTION: PrintParametersSimple() -------------- */
// Used in solver code (e.g., mpfit.cpp, nmsimplex_fit.cpp, etc.) for in-progress
// reporting of current fit parameters
void PrintParametersSimple( ModelObject *model, double *parameters )
{
    vector<string> outputLines;

    model->PrintModelParamsToStrings(outputLines, parameters, NULL);
    for (string line: outputLines)
      printf("%s", line.c_str());
}



/* ---------------- FUNCTION: PrintProgressBar() ------------------- */
/// Prints an updated progress bar.
///    printTemplate should be a string with one "%d" and one "%d" formatting
///    sequences -- e.g., " niter = %3d (%.1f%%)"
///    barWidth = full width of progress bar in characters
void PrintProgressBar( int nDone, int nTotal, string printTemplate, int barWidth )
{
  double  progress = nDone / (1.0*nTotal);
  int  progressBarPos = (int)(progress * barWidth);
  
  printf("[");
  for (int i = 0; i < barWidth; i++) {
    if (i < progressBarPos)
      printf("=");
    else if (i == progressBarPos)
      printf(">");
    else
      printf(" ");
  }
  printf(printTemplate.c_str(), nDone, (100.0 * progress));
  fflush(stdout);
}



/* ---------------- FUNCTION: SplitString() ------------------------ */
/// This function tokenizes a string, splitting it into substrings using
/// delimiters as the separator (delimiters can be more than one character, in
/// which case all of them can serve as delimiters).  The substrings are
/// added to the user-supplied vector<string> tokens.
/// The default value for delimiter is "\n\t ", meaning newlines, tabs, and spaces.
void SplitString( const string& str, vector<string>& tokens, const string& delimiters )
{

  tokens.clear();

  // Skip delimiters at beginning.
  string::size_type  lastPos = str.find_first_not_of(delimiters, 0);
  // Find first "non-delimiter".
  string::size_type  pos = str.find_first_of(delimiters, lastPos);
  if (pos == string::npos) {
    // oops, no delimiters in this string, so just return the whole string
    tokens.push_back(str);
  }
  else {
    while (string::npos != pos || string::npos != lastPos)
    {
      // Found a token, add it to the vector.
      tokens.push_back(str.substr(lastPos, pos - lastPos));
      // Skip delimiters.  Note the "not_of"
      lastPos = str.find_first_not_of(delimiters, pos);
      // Find next "non-delimiter"
      pos = str.find_first_of(delimiters, lastPos);
    }
  }
}


/* ---------------- FUNCTION: SplitStringAdd() --------------------- */
/// Same as SplitString, but the pieces of the input string are *added* to the
/// tokens vector, instead of the tokens vector being cleared first
void SplitStringAdd( const string& str, vector<string>& tokens, const string& delimiters )
{
  // Skip delimiters at beginning.
  string::size_type  lastPos = str.find_first_not_of(delimiters, 0);
  // Find first "non-delimiter".
  string::size_type  pos = str.find_first_of(delimiters, lastPos);

  while (string::npos != pos || string::npos != lastPos)
  {
    // Found a token, add it to the vector.
    tokens.push_back(str.substr(lastPos, pos - lastPos));
    // Skip delimiters.  Note the "not_of"
    lastPos = str.find_first_not_of(delimiters, pos);
    // Find next "non-delimiter"
    pos = str.find_first_of(delimiters, lastPos);
  }
}


/* ---------------- FUNCTION: ChopComment() ------------------------ */
// This function removes the remainder of line after a comment character
// (latter is specified by delimiter, which defaults to '#')
void ChopComment( string& inputString, char delimiter )
{
  string::size_type  loc;
  
  loc = inputString.find(delimiter, 0);
  inputString = inputString.substr(0, loc);
}


/* ---------------- FUNCTION: TrimWhitespace() --------------------- */
// This function removes leading and trailing whitespace from a string; if
// the string is *all* whitespace, then it converts the input string to an
// empty string.  ("Whitespace" = newlines, spaces, or tabs)
void TrimWhitespace( string& stringToModify )
{
  if (stringToModify.empty())
    return;

  string::size_type  startIndex = stringToModify.find_first_not_of(" \t\n");
  string::size_type  endIndex = stringToModify.find_last_not_of(" \t\n");
  if (startIndex == endIndex)
    stringToModify.clear();
  else
    stringToModify = stringToModify.substr(startIndex, (endIndex - startIndex + 1) );
}



/* ---------------- FUNCTION: StripBrackets() ---------------------- */

void StripBrackets( const string& inputFilename, string& strippedFilename )
{
  strippedFilename = inputFilename.c_str();
  ChopComment(strippedFilename, '[');
}



/* ---------------- FUNCTION: GetAllCoordsFromBracket() ------------- */
// Given a string of the form "x1:x2,y1:y2", return x1, x2, y1, and y2
std::tuple<int, int, int, int> GetAllCoordsFromBracket( const string& bracketString )
{
  vector<string>  sectionPieces, subsectionPieces_x, subsectionPieces_y;
  const string star = string("*");
  string  copyBracketString;
  int  x1, x2, y1, y2;

  // default values indicating errors:
  x1 = x2 = y1 = y2 = 0;
  
  // Trim away "[" at start, "]" at end if user accidentally included them
  string::size_type  startIndex = bracketString.find_first_not_of("[");
  string::size_type  endIndex = bracketString.find_last_not_of("]");
  copyBracketString = bracketString.substr(startIndex, (endIndex - startIndex + 1) );

  SplitString(copyBracketString, sectionPieces, ",");
  // handle the x part of the section specification
  if (sectionPieces[0] == star)
    x1 = 1;
  else {
    SplitString(sectionPieces[0], subsectionPieces_x, ":");
    if (subsectionPieces_x.size() != 2) {
      fprintf(stderr, "\nWARNING1: Incorrect image section format!\n");
      fprintf(stderr, "\t\"%s\"\n", copyBracketString.c_str());
      std::make_tuple(0,0,0,0);
    }
    x1 = atoi(subsectionPieces_x[0].c_str());
    x2 = atoi(subsectionPieces_x[1].c_str());
  }
  // handle the y part of the section specification
  if (sectionPieces[1] == star)
    y1 = 1;
  else {
    SplitString(sectionPieces[1], subsectionPieces_y, ":");
    if (subsectionPieces_y.size() != 2) {
      fprintf(stderr, "\nWARNING2: Incorrect image section format!\n");
      fprintf(stderr, "\t\"%s\"\n", copyBracketString.c_str());
      return std::make_tuple(0,0,0,0);
    }
    y1 = atoi(subsectionPieces_y[0].c_str());
    y2 = atoi(subsectionPieces_y[1].c_str());
  }
  
  return std::make_tuple(x1, x2, y1, y2);
}

/* ---------------- FUNCTION: GetStartCoordsFromBracket() ----------- */
/// Given a string of the form "x1:x2,y1:y2", return x1 and y1. Special cases:
///    1. "*,y1:y2" ==> returns 1, y1;
///    2. "x1:x2,*" ==> returns x1, 1
std::tuple<int, int>  GetStartCoordsFromBracket( const string& bracketString,
                           							const string& fileName )
{
  vector<string>  sectionPieces, subsectionPieces_x, subsectionPieces_y;
  const string star = string("*");
  int x1, y1;

  // default values indicating errors:
  x1 = y1 = 0;
  
  SplitString(bracketString, sectionPieces, ",");
  // handle the x part of the section specification
  if (sectionPieces[0] == star)
    x1 = 1;
  else {
    SplitString(sectionPieces[0], subsectionPieces_x, ":");
    if (subsectionPieces_x.size() != 2) {
      fprintf(stderr, "\nWARNING1: Incorrect image section format in \"%s\"!\n",
    					fileName.c_str());
      fprintf(stderr, "\t\"%s\"\n", bracketString.c_str());
      return std::make_tuple(0,0);
    }
    x1 = atoi(subsectionPieces_x[0].c_str());
  }
  // handle the y part of the section specification
  if (sectionPieces[1] == star)
    y1 = 1;
  else {
    SplitString(sectionPieces[1], subsectionPieces_y, ":");
    if (subsectionPieces_y.size() != 2) {
      fprintf(stderr, "\nWARNING2: Incorrect image section format in \"%s\"!\n",
    					fileName.c_str());
      fprintf(stderr, "\t\"%s\"\n", bracketString.c_str());
      return std::make_tuple(0,0);
    }
    y1 = atoi(subsectionPieces_y[0].c_str());
  }
  return std::make_tuple(x1, y1);
}


/* ---------------- FUNCTION: GetPixelStartCoords() ---------------- */

std::tuple<int, int> GetPixelStartCoords( const string& inputFilename )
{
  string::size_type  loc1, loc2, loc3, loc4;
  int  nPieces;
  string  sectionSubstring;
  vector<string>  sectionPieces;
  bool  twoSections = false;
  int xStart, yStart;
  
  // default values indicating errors:
  xStart = yStart = 0;
  
  loc1 = inputFilename.find('[', 0);
  if (loc1 == string::npos) {
    // no image section specified, so we're using the entire image
    xStart = yStart = 1;
    return std::make_tuple(xStart, yStart);
  }
  
  // OK, if we get here, then there's apparently an image section
  loc2 = inputFilename.find(']', loc1);
  if (loc2 == string::npos) {
    fprintf(stderr, "\nWARNING: Incorrect image section format in \"%s\"!\n",
    				inputFilename.c_str());
    return std::make_tuple(0,0);
  }
  // check for possible second bracket group
  loc3 = inputFilename.find("[", loc2);
  if (loc3 != string::npos) {
    // OK, there's more than one set of []
    loc4 = inputFilename.find(']', loc3);
    if (loc4 == string::npos) {
      fprintf(stderr, "\nWARNING: Incorrect image section format in \"%s\"!\n",
      				inputFilename.c_str());
      return std::make_tuple(0,0);
    }
    twoSections = true;
  }
      
  // extract what's inside the first (and possibly only) []
  sectionSubstring = inputFilename.substr(loc1 + 1, loc2 - loc1 - 1);
  SplitString(sectionSubstring, sectionPieces, ",");
  nPieces = sectionPieces.size();
  // two valid possibilites: an image section (nPieces = 2) or an extension number
  // (nPieces = 1)
  if (nPieces == 2) {
    // apparently an image section
    std::tie(xStart, yStart) = GetStartCoordsFromBracket(sectionSubstring, inputFilename);
    // we found a valid (or invalid) image section; ignore anything else...
    return std::make_tuple(xStart, yStart);
  }
  // if we don't have an image section, we need to have an image extension number
  if ((nPieces != 1) || (sectionSubstring.size() < 1)) {
    fprintf(stderr, "\nWARNING: Incorrect image section format in \"%s\"!\n",
  					inputFilename.c_str());
    return std::make_tuple(0,0);
  }
  if (twoSections == false) {
    // OK, just an image extension and nothing else
    xStart = 1;
    yStart = 1;
    return std::make_tuple(xStart, yStart);
  }
      
  if (twoSections == true) {
    // OK, if we get here, there are two bracket groups, and the first was
    // apparently an extension number, so we should expect the second group
    // to be a proper image section
    sectionSubstring = inputFilename.substr(loc3 + 1, loc4 - loc3 - 1);
    SplitString(sectionSubstring, sectionPieces, ",");
    nPieces = sectionPieces.size();
    if (nPieces != 2) {
      fprintf(stderr, "\nWARNING: Incorrect image section format in \"%s\"!\n",
    					inputFilename.c_str());
      return std::make_tuple(0,0);
    }
    // apparently an image section
    std::tie(xStart, yStart) = GetStartCoordsFromBracket(sectionSubstring, inputFilename);
  }
  return std::make_tuple(xStart, yStart);
}


/* ---------------- FUNCTION: DetermineImageOffset() --------------- */
/// Takes user-supplied image filename and determines what, if any, x0 and y0
/// pixel offsets are implied by any section specification in the filename
/// (e.g. "somefile.fits[100:250,400:400]").
/// Note that offsets are always >= 0; if image section starts at x=1 or
/// y=1, then the offsets are by definition 0 or 0, respectively.

std::tuple<int, int> DetermineImageOffset( const std::string &fullImageName )
{
  int  xStart, yStart;

  std::tie(xStart, yStart) = GetPixelStartCoords(fullImageName);
  return std::make_tuple(xStart - 1, yStart - 1);
}



/* ---------------- FUNCTION: ImageFileExists() -------------------- */
/// Function which tests for the existence of an image file, with the following
/// special cases:
///    1. If filename begins with "ftp:" or "http:", we assume it exists;
///    2. Trailing image specifications (e.g. "name.fits[100:200, 100:200]")
/// are ignored, since they are not part of the on-disk filename

bool ImageFileExists(const char * filename)
{
  string  ftpString("ftp://");
  string  httpString("http://");
  string  filenameStr(filename);
  string  baseImageFileName;
  
  // Check for possible ftp:// or http://
  if ((filenameStr.find(ftpString) != string::npos) || 
  		(filenameStr.find(httpString) != string::npos)) {
    return true;
  }
  
  StripBrackets(filenameStr, baseImageFileName);
  return FileExists(baseImageFileName.c_str());
}



/* ---------------- FUNCTION: FileExists() ------------------------- */

bool FileExists(const char * filename)
{
  return ifstream(filename).is_open();
}



/* ---------------- FUNCTION: TimeStamp() -------------------------- */

char * TimeStamp( void )
{  
  time_t  currentTime;
  char *dateString;
  
  currentTime = time(NULL);
  dateString = ctime(&currentTime);
  // Hack! Shift the null-termination up one character to knock out the
  // '\n' which otherwise ends the string.  This works because the
  // output of ctime() is supposed to be a 26-character string.
  dateString[24] = '\0';
  
  return dateString;
}



/* ---------------- FUNCTION: CommandLineError() ------------------- */

void CommandLineError( char errorString[] )
{

  fprintf(stderr, "Error in command line:\n   %s\nExiting...\n",
	 errorString);
  exit(1);
}



/* ---------------- FUNCTION: NotANumber() ------------------------- */
// Possible cases:
//    0, 0.0, 0.1, .1
//    -0.1, -.1?
//    -1
bool NotANumber( const char theString[], int index, int restriction )
{
  int  theCharacter = theString[index];

  switch (restriction) {
    case kAnyInt:
      if (theCharacter == '-')
        return NotANumber( theString, index + 1, kAnyInt );
      else
        return (bool)( ! isdigit(theCharacter) );
    
    case kNonzeroInt:
      if (theCharacter == '-')
        return false;
      else
        return (bool)( ! isdigit(theCharacter) );
    
    case kPosInt:
      if ( isdigit(theCharacter) && (theCharacter != '0') )
        return false;
      else
        return true;
    
    case kAnyReal:
      switch (theCharacter) {
        case '-':
          return NotANumber( theString, index + 1, kAnyReal );
        case '.':
          return NotANumber( theString, index + 1, kAnyInt );
        default:
          return (bool)( ! isdigit(theCharacter) );
      }  /* end switch (theCharacter) */
    
    case kPosReal:
      // THIS STILL NEEDS WORK!
      switch (theCharacter) {
        case '-':
          return true;
        case '.':
          return NotANumber( theString, index + 1, kAnyInt );
        default:
          return (bool)( ! isdigit(theCharacter) );
      }  /* end switch (theCharacter) */
    
    default:
      return true;
  }  /* end switch (restriction) */
}


// returns 1 if input string can successfully be converted to double, 0 if not
int IsNumeric( const char *aString )
{
    char *p;

    if (aString == NULL || *aString == '\0' || isspace(*aString))
      return 0;
    strtod(aString, &p);
    return (*p == '\0');
}



/// \brief Utility function (mainly for debugging) which prints contents of an
///        mp_par structure
string PrintMpPar( mp_par& p )
{
   return PrintToString("%s: fixed: %d, limited = (%d,%d), limits = (%f,%f), offset = %d",
   			p.parname, p.fixed, p.limited[0],p.limited[1], p.limits[0],p.limits[1],
   			p.offset);
}



/* END OF FILE: utilities.cpp -------------------------------------- */
